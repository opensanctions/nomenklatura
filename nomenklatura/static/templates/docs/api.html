
<h3>Using the API</h3>

<p>All of nomenklatura's functionality is exposed by means of a simple, REST-inspired
web interface. The interface represents data exclusively in JSON, and can be accessed 
either directly or via a Python client library.</p>

<h4>Understanding the domain model and entities</h4>
<p>
  Nomenklatura's domain model relies on two key resources: <strong>datasets</strong>
  and <strong>entities</strong>. While the system also knows about user accounts and 
  file uploads, they are not prominently featured in the public API of nomenklatura. 
</p>
<p>
  <strong>Datasets</strong> are used to separate the global namespace of nomenklatura into projects 
  that relate to a topic domain. A dataset has a slug and a label, and it holds a
  set of entities. Datasets also hold settings related to how entity matching is to
  be done, e.g. if similarity matches should be case-sensitive or case-insensitive. 
</p>
<a name="entities"></a>
<p>
  <strong>Entities</strong> are the central domain object of nomenklatura. They are the subject of
  all matching and clustering operations. Each entity can take one of a number of
  different roles: it can be marked as verified to indicate that a user has reviewed
  the entity and found it not to be a duplicate. It can be marked as an alias for 
  another entity, or it can me marked as invalid.
</p>
<p>
  These states are controlled via a variety of properties, which all entities have:
</p>
<ul>
  <li><code>name</code> is the label of an entity, e.g. a person's or company's commonly
    used name.</li>
  <li><code>id</code> is a numeric identifier used for this entity. It is generated by 
    nomenklatura and cannot be modified. It cannot be used to store an external 
    identifier such as a company number.</li>
  <li><code>attributes</code> can contain further properties for the entity, such as 
    alternate URIs, an address or provenance information.</li>
  <li><code>reviewed</code> is a flag that indicates if the entity has been checked 
    by the user for whether it is a duplicate of an existing entity.</li>
  <li><code>invalid</code> is a flag that can be used to mark entities as invalid, 
    thus excluding them from any string matching.</li>
  <li><code>canonical</code> if set, indicates that the entity is an alias for another 
    entity. If a canonical entity is defined, the property will contain a serialized
    version of that entity.</li>
  <li><code>dataset</code> holds the slug of the dataset to which this entity belongs.</li>
  <li><code>creator</code> holds a simplified object of the user account which created
    the entity.</li>

</ul>

<h4>Authentication</h4>
<p>
  Read access to all of nomenklatura's functionality is provided without restriction 
  or the need for authentication. For write operations, such as creating and editing
  datasets and entities, a user will have to provide either a valid session cookie, 
  generated by using OAuth against <a href="https://github.com">GitHub</a>, or an 
  API key. The API key is available in the user profile page for users which have
  logged in.
</p>
<p>
  The API key must be submitted with each request, and it can either be given as the
  <code>api_key</code> query parameter, or as the value of the <code>Authorization</code>
  request header. When an API key is given, nomenklatura still performs authorization 
  checks and return an HTTP 401 error when the credentials are invalid, or an HTTP
  403 error, when the user tries to modify objects which he is not authorized to 
  write.
</p>

<h4>Cross-origin requests</h4>
<p>
  All API responses can be encoded as JSON with padding (JSON-P) by adding a <code>callback</code>
  argument to the request. This will allow remote script inclusion to load data into a 
  web site on a different domain. Cross-origin request sharing (CORS) is not currently 
  supported.
</p>

<a name="pagers"></a>
<h4>Pagers</h4>
<p>
  All collections of HTTP resources such as datasets or entities provide a similar 
  interface that supports pagination by means of limit and offset. A paginated 
  response will be a JSON object with the following properties:
</p>
<ul>
  <li><code>results</code> is an ordered list of the available HTTP resources,
    often serialized in an abridged (shallow) form to reduce the response size.</li>
  <li><code>count</code> gives the overall number of available results, including 
    all available pages.</li>
  <li><code>limit</code> and <code>offset</code> give the current state of the pager,
    indicating the number of results that will be returned with each request and the
    number of results to be skipped before returning results, respectively.</li>
  <li><code>next</code> and <code>previous</code> are two URLs that can be used to 
    retrieve the next or previous page of results. Both properties can be <code>null</code>
    when either no further pages are available or the query returned the first page
    of the result set. Both URLs are also returned in the <code>Link</code> headers
    of the HTTP response.</li> 
</ul>
<p>
  Any pager can be modified using the following query parameters:
</p>
<ul>
  <li><code>limit</code> sets a limit to the number of resources returned. An maximum
    of 1000 resources is enforced, the default is to return 50 resources if no 
    limit has been provided explicitly.</li>
  <li><code>offset</code> instructs the pager to skip the given number of initial 
    records before beginning to return resources.</li>
</ul>

<h3>Request endpoints</h3>

<p>All HTTP resources provided by nomenklatura are available in a versioned API
  namespace.</p>

<h4>Datasets</h4>

<pre class="call">GET /api/2/datasets</pre>
<p>
  Retrieves a collection of all datasets that are currently available on nomenklatura. Standard 
  <a href="#pagers">pager</a> arguments are available.
</p>
<hr class="call-sep">

<pre class="call">POST /api/2/datasets</pre>
<p>
  Operation to create a new dataset. The <code>name</code> and <code>label</code> 
  properties are required. <code>name</code> must be a valid slug, i.e. it may not
  contain non-alphanumeric characters.
</p>
<hr class="call-sep">

<pre class="call">GET /api/2/datasets/:name</pre>
<p>
  Retrieves a single dataset, identified by its <code>name</code>.
</p>
<hr class="call-sep">

<pre class="call">POST /api/2/datasets/:name</pre>
<p>
  Update a dataset, identified by its <code>name</code>. All properties are mutable,
  except for the dataset's<code>name</code>.
</p>
<hr class="call-sep">

<pre class="call">GET /api/2/datasets/:name/reconcile</pre>
<p>
  This endpoint implements the <a href="https://github.com/OpenRefine/OpenRefine/wiki/Reconciliation-Service-API">OpenRefine Reconciliation API</a> for the dataset identified by <code>name</code>. Given a <code>query</code> parameter, the endpoint will attempt to identify 
  matches for the given string. <code>query</code> can also be more comples, JSON-encoded object or hold a list of such queries. Please refer to the Reconciliation API documentation for details on this service.
</p>
<p>
  Although this endpoint returns a collection, it does not implement the default pager mechanism.
</p>
<hr class="call-sep">

<pre class="call">GET /api/2/datasets/:name/review</pre>
<p>
  Return a random entity from the dataset identified by <code>name</code> that has the <code>reviewed</code>
  property set to be false. When all entities in a dataset have been reviewed, this endpoint will return 
  <code>null</code>
</p>
<hr class="call-sep">

<h4>Entities</h4>

<pre class="call">GET /api/2/entities</pre>
<p>
  Retrieves a collection of all entities that are currently available on nomenklatura. The 
  following query parameters are available to extend the functionality of a normal 
  <a href="#pagers">pager</a>:
</p>
<ul>
  <li><code>dataset</code> can be used to identify the <code>name</code> of a dataset to which
    the result set shall be restricted.</li>
  <li><code>filter_name</code> will constrain the result set to only those entities which 
    contain the given string in their name. The filter is not case sensitive.</li>
  <li><code>format</code> can be used to switch to the alternate <code>csv</code>
    representation for the bulk export of entities (i.e. pagination will be disabled). The
    default representation remains <code>json</code>. HTTP-style content negotiation via
    <code>Accept</code> headers is not supported.</li>
  <li><code>download</code> is a flag that can be set to set the <code>Content-Disposition</code>
    header and force the user agent to trigger a file download instead of attempting to render the 
    results to the viewport.</li>
</ul>
<hr class="call-sep">

<pre class="call">POST /api/2/entities</pre>
<p>
  Operation to create a new entity. The <code>name</code> and <code>dataset</code> 
  properties are required. Optional properties are reflected in the 
  domain model documentation <a href="#entities">above</a>.
</p>
<hr class="call-sep">

<pre class="call">GET /api/2/entities/:id</pre>
<p>
  Retrieves a single entity, identified by its <code>id</code>. The semantics of the returned 
  object are documented <a href="#entities">above</a>.
</p>
<hr class="call-sep">

<pre class="call">GET /api/2/entities/:id/aliases</pre>
<p>
  Retrieves a <a href="#pagers">pager</a> of all known aliases for an entity, which is identified by its <code>id</code>.
</p>
<hr class="call-sep">

<pre class="call">POST /api/2/entities/:id</pre>
<p>
  Update an entity, identified by its <code>id</code>. The writeable properties are reflected in the 
  domain model documentation <a href="#entities">above</a>.
</p>
<hr class="call-sep">

<pre class="call">GET /api/2/match</pre>
<p>
  The match API returns a collection of entities that most closely resemble the string given
  in the <code>name</code> query parameter. Matching is based on string similarity and will return
  a set of objects with two properties, <code>score</code> and <code>entity</code>. The
  <code>score</code> is an integer between 0 and 100 to indicate string similarity for the given
  entity. Additionally to the <a href="#pagers">pager</a>, the following query parameters
  are supported:
</p>
<ul>
  <li><code>dataset</code> (required) needs to contain the <code>name</code> of a dataset to which
    the result set shall be restricted.</li>
  <li><code>name</code> will contain the candidate text.</li>
  <li><code>filter</code> will constrain the result set to only those entities whose name begins
    with the given string. The filter is not case sensitive.</li>
  <li><code>exclude</code> can be specified to indicate an entity ID that should not be considered
    for matching, e.g. if the given <code>name</code> is known to be that entities name.</li>
</ul>
<hr class="call-sep">

<h4>Other endpoints</h4>

<pre class="call">GET /api/2/sessions</pre>
<p>
  Retrieve information about the current session. If called without authentication credentials, 
  the response will contain a false value for the property <code>logged_in</code>. If a user 
  is recognized, the endpoint will set <code>logged_in</code> to true, return an
  <code>api_key</code> and a serialized form of the current <code>account</code>.
</p>
<hr class="call-sep">

<pre class="call">GET /api/2/sessions/authz</pre>
<p>
  Retrieve a permission roster for one more multiple datasets. The datasets to included must
  be given as a <code>dataset</code> query parameter with the dataset name. The return value
  will contain an object for each dataset, with <code>read</code>, <code>edit</code> and 
  <code>manage</code> flags set to indicate the current user's permissions.
</p>
<hr class="call-sep">